-- ============================================================================
-- COMMUNITY BUZZ TABLES MIGRATION
-- Version: 1.0.0
-- Date: 2025-01-XX
-- Description: Add tables for Community Buzz feature
-- Includes: Discussions, Groups, Collaborations, Follows, and extends Messages
-- ============================================================================

-- ============================================================================
-- ENUM TYPES
-- ============================================================================

DO $$
BEGIN
    -- Discussion category enum (we'll use VARCHAR for flexibility, but can be enum if preferred)
    -- Keeping as VARCHAR for easier category management
    
    -- Group type enum
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'group_type_enum') THEN
        CREATE TYPE group_type_enum AS ENUM ('regional', 'project', 'network', 'equipment', 'other');
    END IF;
    
    -- Group member role enum
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'group_role_enum') THEN
        CREATE TYPE group_role_enum AS ENUM ('admin', 'moderator', 'member');
    END IF;
    
    -- Collaboration type enum
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'collaboration_type_enum') THEN
        CREATE TYPE collaboration_type_enum AS ENUM ('seeking', 'offering');
    END IF;
    
    -- Collaboration response status enum
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'collaboration_response_status_enum') THEN
        CREATE TYPE collaboration_response_status_enum AS ENUM ('pending', 'accepted', 'declined', 'withdrawn');
    END IF;
END
$$;

-- ============================================================================
-- 1. DISCUSSION TOPICS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS discussion_topics (
    topic_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id INT NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(100) NOT NULL, -- Equipment, Business, Post-Processing, Client Relations, Techniques, Inspiration
    replies_count INT DEFAULT 0,
    views_count INT DEFAULT 0,
    is_hot BOOLEAN DEFAULT FALSE,
    is_pinned BOOLEAN DEFAULT FALSE,
    is_locked BOOLEAN DEFAULT FALSE,
    last_activity_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_discussion_topics_user FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_discussion_topics_user_id ON discussion_topics(user_id);
CREATE INDEX IF NOT EXISTS idx_discussion_topics_category ON discussion_topics(category);
CREATE INDEX IF NOT EXISTS idx_discussion_topics_last_activity ON discussion_topics(last_activity_at DESC);
CREATE INDEX IF NOT EXISTS idx_discussion_topics_is_hot ON discussion_topics(is_hot);
CREATE INDEX IF NOT EXISTS idx_discussion_topics_is_pinned ON discussion_topics(is_pinned);
CREATE INDEX IF NOT EXISTS idx_discussion_topics_created_at ON discussion_topics(created_at DESC);

-- Full-text search index for title and description
CREATE INDEX IF NOT EXISTS idx_discussion_topics_search ON discussion_topics USING GIN (to_tsvector('english', COALESCE(title, '') || ' ' || COALESCE(description, '')));

-- ============================================================================
-- 2. DISCUSSION REPLIES TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS discussion_replies (
    reply_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    topic_id INT NOT NULL,
    user_id INT NOT NULL,
    reply_text TEXT NOT NULL,
    parent_reply_id INT,
    likes_count INT DEFAULT 0,
    is_edited BOOLEAN DEFAULT FALSE,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_discussion_replies_topic FOREIGN KEY (topic_id) REFERENCES discussion_topics(topic_id) ON DELETE CASCADE,
    CONSTRAINT fk_discussion_replies_user FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,
    CONSTRAINT fk_discussion_replies_parent FOREIGN KEY (parent_reply_id) REFERENCES discussion_replies(reply_id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_discussion_replies_topic_id ON discussion_replies(topic_id);
CREATE INDEX IF NOT EXISTS idx_discussion_replies_user_id ON discussion_replies(user_id);
CREATE INDEX IF NOT EXISTS idx_discussion_replies_parent_reply_id ON discussion_replies(parent_reply_id);
CREATE INDEX IF NOT EXISTS idx_discussion_replies_created_at ON discussion_replies(created_at ASC);
CREATE INDEX IF NOT EXISTS idx_discussion_replies_is_active ON discussion_replies(is_active);

-- ============================================================================
-- 3. COMMUNITY GROUPS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS community_groups (
    group_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    creator_id INT NOT NULL,
    group_name VARCHAR(255) NOT NULL,
    group_type group_type_enum NOT NULL DEFAULT 'other',
    description TEXT,
    group_icon_url VARCHAR(500),
    member_count INT DEFAULT 0,
    is_public BOOLEAN DEFAULT TRUE,
    is_active BOOLEAN DEFAULT TRUE,
    last_activity_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_community_groups_creator FOREIGN KEY (creator_id) REFERENCES users(user_id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS idx_community_groups_creator_id ON community_groups(creator_id);
CREATE INDEX IF NOT EXISTS idx_community_groups_group_type ON community_groups(group_type);
CREATE INDEX IF NOT EXISTS idx_community_groups_is_public ON community_groups(is_public);
CREATE INDEX IF NOT EXISTS idx_community_groups_is_active ON community_groups(is_active);
CREATE INDEX IF NOT EXISTS idx_community_groups_last_activity ON community_groups(last_activity_at DESC);
CREATE INDEX IF NOT EXISTS idx_community_groups_created_at ON community_groups(created_at DESC);

-- ============================================================================
-- 4. GROUP MEMBERS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS group_members (
    member_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    group_id INT NOT NULL,
    user_id INT NOT NULL,
    role group_role_enum NOT NULL DEFAULT 'member',
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    unread_count INT DEFAULT 0,
    CONSTRAINT fk_group_members_group FOREIGN KEY (group_id) REFERENCES community_groups(group_id) ON DELETE CASCADE,
    CONSTRAINT fk_group_members_user FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,
    CONSTRAINT uq_group_member UNIQUE (group_id, user_id)
);

CREATE INDEX IF NOT EXISTS idx_group_members_group_id ON group_members(group_id);
CREATE INDEX IF NOT EXISTS idx_group_members_user_id ON group_members(user_id);
CREATE INDEX IF NOT EXISTS idx_group_members_role ON group_members(role);

-- ============================================================================
-- 5. COLLABORATIONS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS collaborations (
    collaboration_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id INT NOT NULL,
    collaboration_type collaboration_type_enum NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT NOT NULL,
    skills JSONB, -- Array of required skills
    location VARCHAR(255),
    date VARCHAR(255), -- Flexible date format (e.g., "2024-02-25", "Ongoing", "Available immediately")
    budget VARCHAR(255), -- Budget range or amount as string
    min_budget DECIMAL(10, 2),
    max_budget DECIMAL(10, 2),
    responses_count INT DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_collaborations_user FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_collaborations_user_id ON collaborations(user_id);
CREATE INDEX IF NOT EXISTS idx_collaborations_type ON collaborations(collaboration_type);
CREATE INDEX IF NOT EXISTS idx_collaborations_location ON collaborations(location);
CREATE INDEX IF NOT EXISTS idx_collaborations_is_active ON collaborations(is_active);
CREATE INDEX IF NOT EXISTS idx_collaborations_created_at ON collaborations(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_collaborations_skills ON collaborations USING GIN (skills);

-- Full-text search index
CREATE INDEX IF NOT EXISTS idx_collaborations_search ON collaborations USING GIN (to_tsvector('english', COALESCE(title, '') || ' ' || COALESCE(description, '')));

-- ============================================================================
-- 6. COLLABORATION RESPONSES TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS collaboration_responses (
    response_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    collaboration_id INT NOT NULL,
    user_id INT NOT NULL,
    message TEXT,
    status collaboration_response_status_enum NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_collaboration_responses_collaboration FOREIGN KEY (collaboration_id) REFERENCES collaborations(collaboration_id) ON DELETE CASCADE,
    CONSTRAINT fk_collaboration_responses_user FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,
    CONSTRAINT uq_collaboration_response UNIQUE (collaboration_id, user_id)
);

CREATE INDEX IF NOT EXISTS idx_collaboration_responses_collaboration_id ON collaboration_responses(collaboration_id);
CREATE INDEX IF NOT EXISTS idx_collaboration_responses_user_id ON collaboration_responses(user_id);
CREATE INDEX IF NOT EXISTS idx_collaboration_responses_status ON collaboration_responses(status);
CREATE INDEX IF NOT EXISTS idx_collaboration_responses_created_at ON collaboration_responses(created_at DESC);

-- ============================================================================
-- 7. FOLLOWS TABLE (Optional but recommended)
-- ============================================================================

CREATE TABLE IF NOT EXISTS follows (
    follow_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    follower_id INT NOT NULL,
    following_id INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_follows_follower FOREIGN KEY (follower_id) REFERENCES users(user_id) ON DELETE CASCADE,
    CONSTRAINT fk_follows_following FOREIGN KEY (following_id) REFERENCES users(user_id) ON DELETE CASCADE,
    CONSTRAINT uq_follow UNIQUE (follower_id, following_id),
    CONSTRAINT chk_follow_self CHECK (follower_id != following_id)
);

CREATE INDEX IF NOT EXISTS idx_follows_follower_id ON follows(follower_id);
CREATE INDEX IF NOT EXISTS idx_follows_following_id ON follows(following_id);
CREATE INDEX IF NOT EXISTS idx_follows_created_at ON follows(created_at DESC);

-- ============================================================================
-- 8. EXTEND MESSAGES TABLE FOR GROUP CHATS
-- ============================================================================

-- First, make receiver_id nullable to support group messages
-- (Group messages don't have a single receiver)
ALTER TABLE messages 
ALTER COLUMN receiver_id DROP NOT NULL;

-- Add group_id column to messages table (nullable for backward compatibility)
ALTER TABLE messages 
ADD COLUMN IF NOT EXISTS group_id INT;

-- Add foreign key constraint for group_id
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'fk_messages_group'
    ) THEN
        ALTER TABLE messages
        ADD CONSTRAINT fk_messages_group 
        FOREIGN KEY (group_id) REFERENCES community_groups(group_id) ON DELETE CASCADE;
    END IF;
END
$$;

-- Create index for group_id
CREATE INDEX IF NOT EXISTS idx_messages_group_id ON messages(group_id);

-- Create composite index for group message queries
CREATE INDEX IF NOT EXISTS idx_messages_group_created ON messages(group_id, created_at DESC) WHERE group_id IS NOT NULL;

-- Add check constraint to ensure either receiver_id or group_id is set (application logic handles this)
-- Note: We allow receiver_id to be NULL for group messages, but at least one should be set
COMMENT ON COLUMN messages.receiver_id IS 'For direct messages. NULL if group_id is set (group message)';
COMMENT ON COLUMN messages.group_id IS 'For group messages. NULL if receiver_id is set (direct message). At least one must be set.';

-- ============================================================================
-- TRIGGERS FOR UPDATED_AT
-- ============================================================================

-- Update timestamp trigger for discussion_topics
DROP TRIGGER IF EXISTS discussion_topics_set_timestamp ON discussion_topics;
CREATE TRIGGER discussion_topics_set_timestamp
BEFORE UPDATE ON discussion_topics
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Update timestamp trigger for discussion_replies
DROP TRIGGER IF EXISTS discussion_replies_set_timestamp ON discussion_replies;
CREATE TRIGGER discussion_replies_set_timestamp
BEFORE UPDATE ON discussion_replies
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Update timestamp trigger for community_groups
DROP TRIGGER IF EXISTS community_groups_set_timestamp ON community_groups;
CREATE TRIGGER community_groups_set_timestamp
BEFORE UPDATE ON community_groups
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Update timestamp trigger for collaborations
DROP TRIGGER IF EXISTS collaborations_set_timestamp ON collaborations;
CREATE TRIGGER collaborations_set_timestamp
BEFORE UPDATE ON collaborations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Update timestamp trigger for collaboration_responses
DROP TRIGGER IF EXISTS collaboration_responses_set_timestamp ON collaboration_responses;
CREATE TRIGGER collaboration_responses_set_timestamp
BEFORE UPDATE ON collaboration_responses
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- BUSINESS LOGIC TRIGGERS
-- ============================================================================

-- Function to update discussion topic replies_count
CREATE OR REPLACE FUNCTION increment_discussion_replies()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE discussion_topics
    SET replies_count = replies_count + 1,
        last_activity_at = CURRENT_TIMESTAMP
    WHERE topic_id = NEW.topic_id;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION decrement_discussion_replies()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE discussion_topics
    SET replies_count = GREATEST(replies_count - 1, 0)
    WHERE topic_id = OLD.topic_id;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_increment_discussion_replies ON discussion_replies;
CREATE TRIGGER trg_increment_discussion_replies
AFTER INSERT ON discussion_replies
FOR EACH ROW
WHEN (NEW.is_active = TRUE)
EXECUTE FUNCTION increment_discussion_replies();

DROP TRIGGER IF EXISTS trg_decrement_discussion_replies ON discussion_replies;
CREATE TRIGGER trg_decrement_discussion_replies
AFTER DELETE ON discussion_replies
FOR EACH ROW
WHEN (OLD.is_active = TRUE)
EXECUTE FUNCTION decrement_discussion_replies();

-- Function to update discussion topic views_count
CREATE OR REPLACE FUNCTION increment_discussion_views()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE discussion_topics
    SET views_count = views_count + 1
    WHERE topic_id = NEW.topic_id;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Function to update community_groups member_count
CREATE OR REPLACE FUNCTION increment_group_members()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE community_groups
    SET member_count = member_count + 1,
        last_activity_at = CURRENT_TIMESTAMP
    WHERE group_id = NEW.group_id;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION decrement_group_members()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE community_groups
    SET member_count = GREATEST(member_count - 1, 0)
    WHERE group_id = OLD.group_id;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_increment_group_members ON group_members;
CREATE TRIGGER trg_increment_group_members
AFTER INSERT ON group_members
FOR EACH ROW
EXECUTE FUNCTION increment_group_members();

DROP TRIGGER IF EXISTS trg_decrement_group_members ON group_members;
CREATE TRIGGER trg_decrement_group_members
AFTER DELETE ON group_members
FOR EACH ROW
EXECUTE FUNCTION decrement_group_members();

-- Function to update collaborations responses_count
CREATE OR REPLACE FUNCTION increment_collaboration_responses()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE collaborations
    SET responses_count = responses_count + 1
    WHERE collaboration_id = NEW.collaboration_id;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION decrement_collaboration_responses()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE collaborations
    SET responses_count = GREATEST(responses_count - 1, 0)
    WHERE collaboration_id = OLD.collaboration_id;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_increment_collaboration_responses ON collaboration_responses;
CREATE TRIGGER trg_increment_collaboration_responses
AFTER INSERT ON collaboration_responses
FOR EACH ROW
EXECUTE FUNCTION increment_collaboration_responses();

DROP TRIGGER IF EXISTS trg_decrement_collaboration_responses ON collaboration_responses;
CREATE TRIGGER trg_decrement_collaboration_responses
AFTER DELETE ON collaboration_responses
FOR EACH ROW
EXECUTE FUNCTION decrement_collaboration_responses();

-- ============================================================================
-- COMMENTS FOR DOCUMENTATION
-- ============================================================================

COMMENT ON TABLE discussion_topics IS 'Discussion topics/threads for Community Buzz Discussions tab';
COMMENT ON TABLE discussion_replies IS 'Replies to discussion topics, supports nested replies';
COMMENT ON TABLE community_groups IS 'Community groups for photographers (My Groups tab)';
COMMENT ON TABLE group_members IS 'Membership tracking for community groups';
COMMENT ON TABLE collaborations IS 'Collaboration opportunities (seeking/offering)';
COMMENT ON TABLE collaboration_responses IS 'Responses to collaboration posts';
COMMENT ON TABLE follows IS 'User follow/following relationships for social features';

-- ============================================================================
-- MIGRATION COMPLETE
-- ============================================================================

-- Verify tables were created
DO $$
BEGIN
    RAISE NOTICE 'Community Buzz tables migration completed successfully!';
    RAISE NOTICE 'Created tables: discussion_topics, discussion_replies, community_groups, group_members, collaborations, collaboration_responses, follows';
    RAISE NOTICE 'Extended: messages table (added group_id for group chats)';
END
$$;

